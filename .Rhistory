N = MN[[2]]
jacobi_out = iterative_solver(M, N, b, v, niters)
errs = jacobi_out[[1]]
errs = errs/norm(v, type='f')
time = jacobi_out[[2]]
## need a little cleaning ##
plot(errs, type='l', lwd=2, col="steelblue",
xlab = "Iteration",
ylab = "Relative Error")
# plot(1:niters, time, type='l', col="steelblue")
}
par(mfrow=c(3,1), mai=c(0.1, .2, .5, .8))
for (alpha in 1:3) {
if (alpha == 1) {
niters = 1000
} else{
niters = 10000
}
A = gen_A(100, alpha)
b = A %*% v
MN = jacobi_split(A)
M = MN[[1]]
N = MN[[2]]
jacobi_out = iterative_solver(M, N, b, v, niters)
errs = jacobi_out[[1]]
errs = errs/norm(v, type='f')
time = jacobi_out[[2]]
## need a little cleaning ##
plot(errs, type='l', lwd=2, col="steelblue",
xlab = "",
ylab = "Relative Error")
# plot(1:niters, time, type='l', col="steelblue")
}
par(mfrow=c(3,1), mai=c(0.4, .4, .2, .2))
for (alpha in 1:3) {
if (alpha == 1) {
niters = 1000
} else{
niters = 10000
}
A = gen_A(100, alpha)
b = A %*% v
MN = jacobi_split(A)
M = MN[[1]]
N = MN[[2]]
jacobi_out = iterative_solver(M, N, b, v, niters)
errs = jacobi_out[[1]]
errs = errs/norm(v, type='f')
time = jacobi_out[[2]]
## need a little cleaning ##
plot(errs, type='l', lwd=2, col="steelblue",
xlab = "",
ylab = "Relative Error")
# plot(1:niters, time, type='l', col="steelblue")
}
par(mfrow=c(3,1), mai=c(0.5, .5, .5, .2))
for (alpha in 1:3) {
if (alpha == 1) {
niters = 1000
} else{
niters = 10000
}
A = gen_A(100, alpha)
b = A %*% v
MN = jacobi_split(A)
M = MN[[1]]
N = MN[[2]]
jacobi_out = iterative_solver(M, N, b, v, niters)
errs = jacobi_out[[1]]
errs = errs/norm(v, type='f')
time = jacobi_out[[2]]
## need a little cleaning ##
plot(errs, type='l', lwd=2, col="steelblue",
xlab = "",
ylab = "Relative Error")
# plot(1:niters, time, type='l', col="steelblue")
}
par(mfrow=c(3,1), mai=c(0.5, .5, .5, .2),
oma = c(1, 1, 0.2, 0.2))
for (alpha in 1:3) {
if (alpha == 1) {
niters = 1000
} else{
niters = 10000
}
A = gen_A(100, alpha)
b = A %*% v
MN = jacobi_split(A)
M = MN[[1]]
N = MN[[2]]
jacobi_out = iterative_solver(M, N, b, v, niters)
errs = jacobi_out[[1]]
errs = errs/norm(v, type='f')
time = jacobi_out[[2]]
## need a little cleaning ##
plot(errs, type='l', lwd=2, col="steelblue",
xlab = "",
ylab = "Relative Error")
# plot(1:niters, time, type='l', col="steelblue")
}
par(mfrow=c(3,1), mai=c(0.5, .5, .5, .2),
oma = c(1.5, 1.5, 0.2, 0.2))
for (alpha in 1:3) {
if (alpha == 1) {
niters = 1000
} else{
niters = 10000
}
A = gen_A(100, alpha)
b = A %*% v
MN = jacobi_split(A)
M = MN[[1]]
N = MN[[2]]
jacobi_out = iterative_solver(M, N, b, v, niters)
errs = jacobi_out[[1]]
errs = errs/norm(v, type='f')
time = jacobi_out[[2]]
## need a little cleaning ##
plot(errs, type='l', lwd=2, col="steelblue",
xlab = "",
ylab = "Relative Error")
# plot(1:niters, time, type='l', col="steelblue")
}
x = seq(-100, 100, length.out = 201)
width = pi
width = pi/2
cos(x * omega[1])
x = seq(-100, 100, length.out = 201)
n_omg = 1001
width = pi/n_omg
omega = seq(width/2, pi - width/2, length.out=n_omg)
cos(x * omega[1])
out = cos(x * omega[1])
rbf = function(tau, ell){
return( exp(-0.5 * tau^2/ell^2))
}
out = rbf(x, 1)
plot(x, out)
omg = 0:5
k = rbf(seq(0, 100, length.out=1001), 1)
k = as.arary(rbf(seq(0, 100, length.out=1001), 1))
k = as.array(rbf(seq(0, 100, length.out=1001), 1))
omg = as.array(0:5)
k = as.array(rbf(seq(0, 100, length.out=1001), 1))
omg = as.array(0:5)
x - seq(0, 100, length.out=1001)
k = as.array(rbf(x, 1))
omg = as.array(0:5)
x = seq(0, 100, length.out=1001)
k = as.array(rbf(x, 1))
t(k) %*% cos(x * omg[0])
out = cos(x * omg[0])
ou
ou
out
out = cos(x * omg[1])
out
k %*% t(cos(x * omg[0]))
out = k %*% t(cos(x * omg[0]))
out
out
out
k %*% t(cos(x * omg[1]))
out
out = cos(x * omg[1])
k %*% t(k)
n_x = 1001
x = seq(0, 100, length.out=n_x)
k = as.array(rbf(x, 1), dim=c(1, n_x))
k %*% t(k)
t(k) %*% k
t(k) %*% cos(x * omg[1])
t(k) %*% cos(x * omg[2])
build()
library(devtools)
build()
setwd("~/Google Drive/Spring 19/STSCI6520/HW2/")
build()
install()
gen_A
gen_A()
document()
build()
install()
A = gen_A(100, 3)
v = as.matrix(rep(c(1,0), n/2))
n=100
A = gen_A(n, 3)
v = as.matrix(rep(c(1,0), n/2))
b = A %*% b
b = A %*% v
out = jacobi_parallel(A, b)
?makeCluster
registerDoParallel
?registerDoParallel
build
build()
install()
n=100
A = gen_A(n, 3)
v = as.matrix(rep(c(1,0), n/2))
b = A %*% v
out = jacobi_parallel(A, b)
?foreach
build()
install()
n=100
A = gen_A(n, 3)
v = as.matrix(rep(c(1,0), n/2))
b = A %*% v
out = jacobi_parallel(A, b)
?dopar
??dopar
#'
#' Numerically approximates solutions to linear systems like Ax=b
#' @param  A Input Matrix for Ax=b
#' @param  b right-hand side vector for Ax=b
#' @param  n_iters the number of jacobi iterations to run. Degault=100
#' @param  ncores the number of cores to use. Default=1
#' @return Returns x, the approximate solution to Ax=b
#' @export
#' @examples
#' algo_leverage(x, y, subsample='lev', r=10)
jacobi_parallel = function(A, b, n_iters=100, ncores=1){
cl = parallel::makeCluster(ncores)
doParallel::registerDoParallel(cl)
v = as.matrix(rep(c(1,0), n/2))
x_cur = as.matrix(rep(0, n))
for (iter in 1:n_iters) {
x_list = foreach::foreach(i=1:n) foreach::%dopar% {
x = (b[i, 1] - A[i, -i] %*% x_cur[-i])/A[i,i]
}
x_cur = unlist(x_list)
}
doParallel::stopCluster(cl)
return(x_cur)
}
#'
#' Numerically approximates solutions to linear systems like Ax=b
#' @param  A Input Matrix for Ax=b
#' @param  b right-hand side vector for Ax=b
#' @param  n_iters the number of jacobi iterations to run. Degault=100
#' @param  ncores the number of cores to use. Default=1
#' @return Returns x, the approximate solution to Ax=b
#' @export
#' @examples
#' algo_leverage(x, y, subsample='lev', r=10)
jacobi_parallel = function(A, b, n_iters=100, ncores=1){
cl = parallel::makeCluster(ncores)
doParallel::registerDoParallel(cl)
v = as.matrix(rep(c(1,0), n/2))
x_cur = as.matrix(rep(0, n))
for (iter in 1:n_iters) {
x_list = foreach::foreach(i=1:n) foreach::%dopar% {
x = (b[i, 1] - A[i, -i] %*% x_cur[-i])/A[i,i]
}
x_cur = unlist(x_list)
}
doParallel::stopCluster(cl)
return(x_cur)
}
rm(list = ls())
#'
#' Numerically approximates solutions to linear systems like Ax=b
#' @param  A Input Matrix for Ax=b
#' @param  b right-hand side vector for Ax=b
#' @param  n_iters the number of jacobi iterations to run. Degault=100
#' @param  ncores the number of cores to use. Default=1
#' @return Returns x, the approximate solution to Ax=b
#' @export
#' @examples
#' algo_leverage(x, y, subsample='lev', r=10)
jacobi_parallel = function(A, b, n_iters=100, ncores=1){
cl = parallel::makeCluster(ncores)
doParallel::registerDoParallel(cl)
v = as.matrix(rep(c(1,0), n/2))
x_cur = as.matrix(rep(0, n))
for (iter in 1:n_iters) {
x_list = foreach::foreach(i=1:n) foreach::%dopar% {
x = (b[i, 1] - A[i, -i] %*% x_cur[-i])/A[i,i]
}
x_cur = unlist(x_list)
}
doParallel::stopCluster(cl)
return(x_cur)
}
#'
#' Numerically approximates solutions to linear systems like Ax=b
#' @param  A Input Matrix for Ax=b
#' @param  b right-hand side vector for Ax=b
#' @param  n_iters the number of jacobi iterations to run. Degault=100
#' @param  ncores the number of cores to use. Default=1
#' @return Returns x, the approximate solution to Ax=b
#' @export
#' @examples
#' algo_leverage(x, y, subsample='lev', r=10)
jacobi_parallel = function(A, b, n_iters=100, ncores=1){
cl = parallel::makeCluster(ncores)
doParallel::registerDoParallel(cl)
v = as.matrix(rep(c(1,0), n/2))
x_cur = as.matrix(rep(0, n))
for (iter in 1:n_iters) {
x_list = foreach::foreach(i=1:n) foreach::%dopar% {
x = (b[i, 1] - A[i, -i] %*% x_cur[-i])/A[i,i]
}
x_cur = unlist(x_list)
}
parallel::stopCluster(cl)
return(x_cur)
}
jacobi_parallel = function(A, b, n_iters=100, ncores=1){
cl = parallel::makeCluster(ncores)
doParallel::registerDoParallel(cl)
v = as.matrix(rep(c(1,0), n/2))
x_cur = as.matrix(rep(0, n))
for (iter in 1:n_iters) {
x_list = foreach::foreach(i=1:n) foreach::%dopar% {
x = (b[i, 1] - A[i, -i] %*% x_cur[-i])/A[i,i]
}
x_cur = unlist(x_list)
}
parallel::stopCluster(cl)
return(x_cur)
}
test = function(){
print("help")
}
jacobi_parallel = function(A, b, n_iters=100, ncores=1){
cl = parallel::makeCluster(ncores)
doParallel::registerDoParallel(cl)
v = as.matrix(rep(c(1,0), n/2))
x_cur = as.matrix(rep(0, n))
for (iter in 1:n_iters) {
x_list = foreach::foreach(i=1:n) foreach::%dopar% {
x = (b[i, 1] - A[i, -i] %*% x_cur[-i])/A[i,i]
}
x_cur = unlist(x_list)
}
parallel::stopCluster(cl)
return(x_cur)
}
n=100
A = gen_A(n, 3)
v = as.matrix(rep(c(1,0), n/2))
b = A %*% v
#' @export
gen_A = function(n, alpha){
A = matrix(0, nrow=n, ncol=n)
diag(A) = rep(alpha, n)
del = row(A) - col(A)
A[abs(del) == 1] = -1
return(A)
}
A = gen_A(n, 3)
v = as.matrix(rep(c(1,0), n/2))
b = A %*% v
out = jacobi_parallel(A, b)
test = function(){
print("help")
}
jacobi_parallel = function(A, b, n_iters=100, ncores=1){
cl = parallel::makeCluster(ncores)
doParallel::registerDoParallel(cl)
v = as.matrix(rep(c(1,0), n/2))
x_cur = as.matrix(rep(0, n))
for (iter in 1:n_iters) {
x_list = foreach::foreach(i=1:n) foreach::%dopar% {
x = (b[i, 1] - A[i, -i] %*% x_cur[-i])/A[i,i]
}
x_cur = unlist(x_list)
}
parallel::stopCluster(cl)
return(x_cur)
}
jacobi_parallel = function(A, b, n_iters=100, ncores=1){
cl = parallel::makeCluster(ncores)
doParallel::registerDoParallel(cl)
v = as.matrix(rep(c(1,0), n/2))
x_cur = as.matrix(rep(0, n))
for (iter in 1:n_iters) {
x_list = foreach::foreach(i=1:n) %foreach::dopar% {
x = (b[i, 1] - A[i, -i] %*% x_cur[-i])/A[i,i]
}
x_cur = unlist(x_list)
}
parallel::stopCluster(cl)
return(x_cur)
}
out = jacobi_parallel(A, b)
jacobi_parallel = function(A, b, n_iters=100, ncores=1){
cl = parallel::makeCluster(ncores)
doParallel::registerDoParallel(cl)
v = as.matrix(rep(c(1,0), n/2))
x_cur = as.matrix(rep(0, n))
for (iter in 1:n_iters) {
x_list = foreach::foreach(i=1:n) %dopar% {
x = (b[i, 1] - A[i, -i] %*% x_cur[-i])/A[i,i]
}
x_cur = unlist(x_list)
}
parallel::stopCluster(cl)
return(x_cur)
}
out = jacobi_parallel(A, b)
library(foreach)
out = jacobi_parallel(A, b)
getwd()
build()
library(devtools)
build()
install()
n=100
A = gen_A(n, 3)
v = as.matrix(rep(c(1,0), n/2))
b = A %*% v
out = jacobi_parallel(A, b)
out
out = jacobi_parallel(A, b, n_iters=2)
out
out = jacobi_parallel(A, b, n_iters=2, ncores=2)
out = jacobi_parallel(A, b, n_iters=100, ncores=2)
out = jacobi_parallel(A, b, n_iters=100, ncores=1)
out = jacobi_parallel(A, b, n_iters=100, ncores=1)
out = jacobi_parallel(A, b, n_iters=1000, ncores=2)
out = jacobi_parallel(A, b, n_iters=1000, ncores=2)
n=1000
A = gen_A(n, 3)
v = as.matrix(rep(c(1,0), n/2))
b = A %*% v
out = jacobi_parallel(A, b, n_iters=10, ncores=2)
out = jacobi_parallel(A, b, n_iters=10, ncores=2)
start = proc.time()
out = jacobi_parallel(A, b, n_iters=10, ncores=2)
start = proc.time()
out = jacobi_parallel(A, b, n_iters=10, ncores=2)
print(proc_time() - start)
start = proc.time()
out = jacobi_parallel(A, b, n_iters=10, ncores=2)
print(proc.time() - start)
start = proc.time()
out = jacobi_parallel(A, b, n_iters=10, ncores=1)
print(proc.time() - start)
start = proc.time()
out = jacobi_parallel(A, b, n_iters=100, ncores=1)
print(proc.time() - start)
start = proc.time()
out = jacobi_parallel(A, b, n_iters=100, ncores=3)
print(proc.time() - start)
otu
out
clear
build()
install()
?jacobi_parallel
library(HW2)
A = gen_A(100, 4)
x = as.matrix(rep(c(1,0), 50))
b = A %*% x
approx_x = jacobi_parallel(A, b, n_iters=100, ncores=1)
library(HW2)
A = gen_A(100, 4)
x = as.matrix(rep(c(1,0), 50))
b = A %*% x
approx_x = jacobi_parallel(A, b, n_iters=100, ncores=1)
library(HW2)
build()
install()
A = gen_A(100, 4)
x = as.matrix(rep(c(1,0), 50))
b = A %*% x
approx_x = jacobi_parallel(A, b, n_iters=100, ncores=1)
n=1000
A = gen_A(n, 3)
v = as.matrix(rep(c(1,0), n/2))
b = A %*% v
out = jacobi_parallel(A, b, n_iters=100, ncores=1)
build()
install()
build()
install()
n=100
A = gen_A(n, 3)
v = as.matrix(rep(c(1,0), n/2))
b = A %*% v
# start = proc.time()
out = jacobi_parallel(A, b, n_iters=100, ncores=1)
out
# start = proc.time()
out = jacobi_parallel(A, b, n_iters=100, ncores=2)
out
rm(out)
# start = proc.time()
out = jacobi_parallel(A, b, n_iters=100, ncores=2)
ouy
out
# start = proc.time()
n = 10
out = jacobi_parallel(A, b, n_iters=100, ncores=2)
dim(A)
dim(A)[]
out = jacobi_parallel(A, b, n_iters=100, ncores=2)
build()
install()
out = jacobi_parallel(A, b, n_iters=100, ncores=2)
# start = proc.time()
n = 10
out = jacobi_parallel(A, b, n_iters=100, ncores=2)
build()
install()
# start = proc.time()
n = 10
out = jacobi_parallel(A, b, n_iters=100, ncores=2)
